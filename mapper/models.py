"""
Database models for Dropped Kerb Mapper:
- CustomUser: Extends Django's AbstractUser with accessibility-related fields.
- County: GIS model storing county boundaries.
- LocalAuthority: GIS model storing local authority boundaries.
- Report: Stores individual dropped-kerb reports with automatic
  reverse-geocoding, spatial lookups, and file attachments.
"""
import logging
from django.contrib.gis.db import models as geomodels
from django.contrib.auth.models import AbstractUser
from django.contrib.gis.geos import Point
from django.conf import settings
from django.core.exceptions import ValidationError
from django.db import models
from multiselectfield import MultiSelectField
from cloudinary.models import CloudinaryField
from geopy import Nominatim
from geopy.exc import GeopyError

logger = logging.getLogger(__name__) # Set up logging for this module

class CustomUser(AbstractUser):
    """
    Extends Django's AbstractUser to capture accessibility-related user details.

    Attributes:
        uses_mobility_device (bool):
            Indicates whether the user uses a wheeled mobility device.
        mobility_device_type (str | None):
            Type of mobility device the user uses. Choices include:
            'manual_wheelchair', 'manual_wheelchair_with_powered_front_attachment',
            'all_terrain_wheelchair','powered_wheelchair', 'mobility_scooter',
            'tricycle', 'handcycle', 'adapted_bicycle', 'bicycle', 'other'.
        is_carer (bool):
            Indicates whether the user is a carer for someone using a mobility device..
    """
    # Add mobility device fields
    uses_mobility_device = models.BooleanField(
        default=False,
        verbose_name="Uses a wheeled mobility device"
    )
    MOBILITY_DEVICE_CHOICES = (
        ('manual_wheelchair', 'Manual Wheelchair'),
        ('powered_wheelchair', 'Powered Wheelchair'),
        ('manual_wheelchair_with_powered_front_attachment',
            'Manual Wheelchair with Powered Front Attachment'),
        ('all_terrain_wheelchair', 'All Terrain Wheelchair'),
        ('mobility_scooter', 'Mobility Scooter'),
        ('tricycle', 'Tricycle'),
        ('handcycle', 'Handcycle'),
        ('adapted_bicycle', 'Adapted Bicycle'),
        ('bicycle', 'Bicycle'),
        ('other', 'Other'),
    )
    mobility_device_type = models.CharField(
        max_length=50,
        choices=MOBILITY_DEVICE_CHOICES,
        blank=True,
        null=True,
        verbose_name="Mobility Device Type"
    )
    is_carer = models.BooleanField(
        default=False,
        verbose_name="Uses a wheeled mobility device"
    )

class County(geomodels.Model):
    """
    A geospatial model representing a county boundary.
    Each instance stores the county's name and its polygon geometry 
    (in WGS84) for spatial lookups (e.g., reverse geocoding a point
    to determine which county it falls within).

    Attributes:
        county (str):
            The human-readable name of the county.
        polygon (MultiPolygonField):
            The GIS boundary of the county, stored as a MultiPolygon
            using SRID 4326 (WGS84 latitude/longitude).
    """
    county = models.CharField(max_length=100)
    polygon = geomodels.MultiPolygonField(srid=4326)
    class Meta:
        """
        Model metadata for County.

        Configures how Django displays and handles the County model, including:
        - verbose_name_plural: the plural display name ("Counties") used
            in the admin and autogenerated interfaces.
        """
        verbose_name_plural = "Counties"  # Set the plural name to "Counties"

    def __str__(self):
        """
        Return the county's name as the string representation of this model.

        This is used by Django admin and any place where str(county_instance)
        is called to display the county in a human-readable form.
        
        :return: County name (string)
        """
        return str(self.county)


class LocalAuthority(geomodels.Model):
    """
    LocalAuthority

    A geospatial model representing a local authority boundary.
    Each instance stores the authority's name and its polygon geometry
    (in WGS84) for spatial lookups, e.g., determining which local authority
    a geographic point falls within.

    Attributes:
        local_authority (str):
            The human-readable name of the local authority.
        polygon (MultiPolygonField):
            The GIS boundary of the authority, stored as a MultiPolygon
            using SRID 4326 (WGS84 latitude/longitude).
    """
    local_authority = models.CharField(max_length=100)
    polygon = geomodels.MultiPolygonField(srid=4326)

    class Meta:
        """
        Model metadata for LocalAuthority.

        Configures Django's handling of the LocalAuthority model, including:
        - verbose_name_plural: sets the plural display name ("Local Authorities")
          used in the admin site and other autogenerated interfaces.
        """
        verbose_name_plural = "Local Authorities"

    def __str__(self):
        """
        Return the local authority's name as the string representation of this model.

        This is used by Django admin and anywhere str(local_authority_instance)
        is called to display the local authority in a human-readable form.

        :return: The `local_authority` field value.
        """
        return str(self.local_authority)

class Report(models.Model):
    """
    Stores an individual dropped-kerb report, including location,
    condition, reasons for condition choice, comments and photo. 
    Automatically handles:
      - Sequential user-specific report numbering
      - Spatial lookups to assign County and LocalAuthority via GeoDjango
      - Reverse geocoding to populate a human-readable place_name
      - Validation that reasons only apply to, and are given for red/orange conditions

    Attributes:
        user_report_number (int | None):
            Sequential number unique per user.
        latitude (Decimal):
            Latitude of the report location.
        longitude (Decimal):
            Longitude of the report location.
        county (County | None):
            Linked County containing the point, or None if none match.
        local_authority (LocalAuthority | None):
            Linked LocalAuthority containing the point, or None if none match.
        place_name (str | None):
            Human-readable name derived from reverse geocoding.
        condition (str):
            Accessibility condition; one of 'none','green','orange','red','white'.
            where: 
                - red: Dangerous or unusable
                - orange: Usable but needs improvement
                - green: Usable and in good condition
                - white: Dropped kerb missing or preventing access
                - none: No condition reported
        reasons (list[str] | None):
            Optional list of selected reasons for red/orange conditions.
        comments (str):
            Optional user comments.
        photo (CloudinaryField | None):
            Optional uploaded photo of the dropped kerb.
        created_at (datetime):
            Timestamp when the report was created.
        updated_at (datetime):
            Timestamp when the report was last updated.
        user (AUTH_USER_MODEL | None):
            Reference to the user who submitted the report.
        username (str | None):
            Cached username of the report creator.

    Methods:
        reverse_geocode(lat, lon) -> bool:
            Populates `place_name` via Nominatim; returns True on success.
        clean() -> None:
            Ensures `reasons` is empty unless `condition` is 'red' or 'orange'.
        save(*args, **kwargs) -> None:
            Overrides save to auto-assign `user_report_number`, compute spatial
            fields, reverse-geocode, and then persist the instance.
    """
    TRAFFIC_LIGHT_CHOICES = [
        ('none', 'None'),     # No condition reported
        ('green', 'Green'),   # Usable and in good condition
        ('orange', 'Orange'), # Usable but needs improvement
        ('red', 'Red'),       # Dangerous or unusable
        ('white', 'White'),   # Dropped kerb missing or preventing access
    ]

    ALLOWED_REASONS = [
        ('steep_gradient', 'Steep gradient'),
        ('lip_too_high', 'Lip too high'),
        ('cobbles', 'Cobblestones'),
        ('obstacle', 'Obstacle'),
        ('no_visual_marking', 'No visual marking'),
        ('no_tactile_paving', 'No tactile paving'),
        ('narrow_pavement', 'Narrow pavement'),
        ('uneven_road_surface', 'Uneven road surface'),
        ('uneven_pavement_surface', 'Uneven pavement surface'),
        ('tight_turning_circle', 'Tight turning circle'),
        ('incorrectly_angled', 'Incorrectly angled'),
        ('broken_road_surface', 'Broken road surface'),
        ('broken_pavement_surface', 'Broken pavement surface'),
        ('accessibility_barrier', 'Accessibility barrier'),
    ]

    # Model fields and their types
    # Create a unique report number for each user
    user_report_number = models.PositiveIntegerField(null=True, blank=True)
    # Store location as latitude and longitude
    latitude = models.DecimalField(max_digits=9, decimal_places=6)
    longitude = models.DecimalField(max_digits=9, decimal_places=6)
    # ForeignKey to the matching County
    county = models.ForeignKey(County, null=True, blank=True, on_delete=models.SET_NULL)
    local_authority = models.ForeignKey(LocalAuthority,
                                        null=True, blank=True, on_delete=models.SET_NULL)
    # place name (get via reverse geocoding)
    place_name = models.CharField(max_length=1000, blank=True, null=True)
    # Uses a choices field to enforce the available traffic light ratings.
    condition = models.CharField(max_length=6, choices=TRAFFIC_LIGHT_CHOICES)
    # Each instance represents an option (checkbox) that explains why a particular
    # traffic light condition was chosen
    reasons = MultiSelectField(choices=ALLOWED_REASONS, blank=True, null=True)
    comments = models.CharField(max_length=1000, blank=True) # Optional comments
    photo = CloudinaryField('image', blank=True, null=True) # Optional photo of the dropped kerb
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    user = models.ForeignKey(
        settings.AUTH_USER_MODEL,  # custom user model
        on_delete=models.SET_NULL,
        related_name='reports',
        null=True,
        blank=True
    )

    username = models.CharField(max_length=150, blank=True, null=True)

    class Meta:
        """
        Model metadata for Report.

        Configures how Django orders and displays Report instances, including:
          - ordering: Default sort order ('-created_at' for newest first).
          - verbose_name: Singular display name ("Dropped Kerb Report").
          - verbose_name_plural: Plural display name ("Dropped Kerb Reports").
          - get_latest_by: Field used by get_latest() and latest() methods ("created_at").
          - indexes: Database indexes on 'condition' and 'user' for faster queries.
        """
        ordering = ['-created_at']
        verbose_name = "Dropped Kerb Report"
        verbose_name_plural = "Dropped Kerb Reports"
        get_latest_by = "created_at"
        indexes = [
            models.Index(fields=['condition']),
            models.Index(fields=['user']),
        ]

    def reverse_geocode(self, lat, lon):
        """
        Populate `self.place_name` by reverse geocoding the given coordinates.

        Uses geopy's Nominatim service to look up address details at the specified
        latitude (`lat`) and longitude (`lon`). Iterates over returned address
        components until a boundary key (e.g. 'county', 'state', 'country', etc.)
        or ISO code is encountered, collects unique values encountered before that
        break point, and joins them with commas to form a human-readable place name.

        On success:
          - Sets `self.place_name` to the joined components (or None if no components).
          - Returns True.

        On failure (any GeopyError):
          - Logs the error via the module logger.
          - Leaves `self.place_name` unchanged.
          - Returns False.

        :param float|Decimal lat: Latitude in decimal degrees.
        :param float|Decimal lon: Longitude in decimal degrees.
        :return bool: True if geocoding succeeded and `place_name` was set, False otherwise.
        """
        try:
            geolocator = Nominatim(user_agent="Dropped-Kerb-Mapper")
            location = geolocator.reverse(f"{lat},{lon}", zoom=17, addressdetails=True)
            address = location.raw.get('address', {})
            values_until_county = []
            for key, value in address.items():
                if key in ['county', 'state', 'country',
                           'postcode', 'country_code', 'province'] or key.startswith('ISO'):
                    break
                if value not in values_until_county:
                    values_until_county.append(value) # Avoid duplicates in the place name
            # Join the values into a single string
            self.place_name = ", ".join(values_until_county) if values_until_county else None
            return True
        except GeopyError as e:
            logger.error("Reverse geocoding failed: %s", e)
            return False

    def clean(self):
        """
        Validate that 'reasons' and 'comments' fields align with the selected 'condition'.

        Rules:
          - If condition is 'red' or 'orange', at least one reason must be provided.
          - If condition is not 'red' or 'orange', no reasons should be present.
          - If condition is 'white', comments must be provided to explain the missing kerb.

        Raises:
            ValidationError: When any of the above rules are violated.
        """
        super().clean()
        if self.condition in ['red', 'orange'] and not self.reasons:
            raise ValidationError("Reasons must be provided for red or orange conditions.")
        if self.condition not in ['red', 'orange'] and self.reasons:
            raise ValidationError("Reasons can only be provided for red or orange conditions.")
        if self.condition == 'white' and not self.comments:
            raise ValidationError("Comments must be provided for 'none' condition.")

    def save(self, *args, **kwargs):
        """
        Override the default save to enrich and validate report data before persisting.

        - Assigns a sequential user_report_number for this user if not already set.
        - Rounds latitude and longitude, builds a GeoDjango Point, and finds the matching
          County and LocalAuthority (or sets them to None if no match).
        - Populates the `username` field from the related user if missing.
        - Calls `reverse_geocode` to set `place_name` based on the coordinates.
        - Finally, calls `super().save(*args, **kwargs)` to persist the instance.

        :param args: Positional arguments forwarded to the parent save().
        :param kwargs: Keyword arguments forwarded to the parent save().
        :return: None
        """
        # Assign the next report number for this specific user
        if self.user and not self.user_report_number:
            # Get the highest report number for this user and increment it
            # 'objects' manager is added by Django's ModelBase
            last_report = Report.objects.filter(user=self.user) \
                                        .order_by('-user_report_number') \
                                        .first()
            self.user_report_number = (last_report.user_report_number + 1) if last_report else 1

        # Create a GeoDjango Point
        lon = round(self.longitude, 6)
        lat = round(self.latitude, 6)
        point = Point((lon, lat))

        # Find the mataching County
        # 'objects' manager is added by Django's ModelBase
        matching_county = County.objects.filter(polygon__contains=point).first()
        if matching_county:
            self.county = matching_county
        else:
            self.county = None  # Or handle cases where no county matches.

        # Find the matching local authority
        matching_local_authority = LocalAuthority.objects.filter(polygon__contains=point).first()
        if matching_local_authority:
            self.local_authority = matching_local_authority
        else:
            self.local_authority = None

        # Automatically set the username field if the user is set
        if self.user and not self.username:
            self.username = self.user.username

        # Try reverse geocode the latitude and longitude to get the place name
        self.reverse_geocode(self.latitude, self.longitude)

        super().save(*args, **kwargs)

    def __str__(self):
        """
        Return a detailed, human-readable summary of the report.

        The summary includes:
          - Report primary key (#pk)
          - Condition (e.g. "red", "green")
          - Username (or "Unknown User" if missing)
          - Listed reasons or "None"
          - Comments or "None"
          - Whether a photo is attached ("Yes" or "No")
          
        :return: Composite string describing the report instance.
        """
        # Represent reasons or show 'None'
        reasons_str = ', '.join(self.reasons) if self.reasons else 'None'
        # Represent comments or show 'None'
        comments_str = self.comments or 'None'
        # Indicate if a photo is attached
        photo_str = 'Yes' if self.photo else 'No'
        # Build a detailed string representation
        return (
            f"Report #{self.pk}: {self.condition} by {self.username or 'Unknown User'} | "
            f"Reasons: {reasons_str} | Comments: {comments_str} | Photo attached: {photo_str}"
        )
